<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Donga Police: Royal Chits Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        window.process = { env: { NODE_ENV: 'development' } };
    </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --bg-dark: #111827; --bg-light: #f0f9ff;
            --text-dark: #e5e7eb; --text-light: #1f2937;
            --surface-dark: #1f2937; --surface-light: #ffffff;
            --primary: #3b82f6;
        }
        html.dark { --bg-main: var(--bg-dark); --text-main: var(--text-dark); --surface-main: var(--surface-dark); }
        html:not(.dark) { --bg-main: var(--bg-light); --text-main: var(--text-light); --surface-main: var(--surface-light); }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-main); color: var(--text-main); }
        .screen { display: none; width: 100%; height: 100%; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 1.25rem; box-sizing: border-box; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.5s ease-in-out; }
        .screen.active { display: flex; opacity: 1; z-index: 10; }
        .btn { padding: 0.75rem 1.75rem; font-size: 1.1rem; font-weight: bold; border-radius: 0.75rem; cursor: pointer; transition: all 0.2s ease; border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .btn:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .chit-scene { perspective: 1000px; }
        .chit { transform-style: preserve-3d; transition: transform 0.8s; }
        .chit.is-flipped { transform: rotateY(180deg); }
        .chit-face { backface-visibility: hidden; -webkit-backface-visibility: hidden; }
        .confetti { position: absolute; animation-timing-function: linear; user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="audio-container"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, collection, writeBatch, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const { useState, useEffect, useCallback, useRef } = React;

        // --- Sound Manager ---
        const playSound = (() => {
            let sounds;
            return (sound, note = 'C4', duration = '8n') => {
                if (!sounds) {
                    sounds = {
                        flip: new Tone.Synth({ oscillator: { type: 'sine' } }).toDestination(),
                        click: new Tone.PolySynth(Tone.Synth).toDestination(),
                        win: new Tone.Synth({ oscillator: { type: 'triangle8' } }).toDestination(),
                        lose: new Tone.Synth({ oscillator: { type: 'sawtooth' } }).toDestination(),
                        message: new Tone.MembraneSynth().toDestination(),
                        ptt_on: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, release: 0.1 } }).toDestination(),
                        ptt_off: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, release: 0.1 } }).toDestination(),
                    };
                }
                if (Tone.context.state === 'running') sounds[sound].triggerAttackRelease(note, duration);
            };
        })();

        // --- UI Components ---
        const Confetti = ({ type }) => {
            if (!type) return null;
            let symbols = [];
            if (type === 'both_win') symbols = ['üéâ', 'üéä', '‚ú®', 'üèÜ'];
            if (type === 'one_win') symbols = ['üéÜ', 'üéá', '‚ú®'];
            if (type === 'lose') symbols = ['üò¢', 'üëé', 'üé∫'];
            
            const confettiPieces = Array.from({ length: 50 }, (_, i) => {
                const style = {
                    left: `${Math.random() * 100}%`,
                    top: `${-20}%`,
                    fontSize: `${1 + Math.random() * 1.5}rem`,
                    animation: `fall ${2 + Math.random() * 2}s linear ${Math.random() * 2}s forwards`
                };
                return <div key={i} className="confetti" style={style}>{symbols[i % symbols.length]}</div>;
            });
            return <div className="absolute inset-0 pointer-events-none">{confettiPieces}</div>;
        };
        const style = document.createElement('style');
        style.textContent = `@keyframes fall { to { top: 120%; transform: rotate(${Math.random() * 720}deg); } }`;
        document.head.append(style);
        
        // --- Main App Component ---
        function App() {
            const [gameState, setGameState] = useState('home');
            const [gameData, setGameData] = useState(null);
            const [userId, setUserId] = useState(null);
            const [username, setUsername] = useState('');
            const [isDarkMode, setIsDarkMode] = useState(true);
            
            const dbRef = useRef();
            const authRef = useRef();
            let gameUnsubscribe = useRef(null);
            
            const appId = 'donga-police-game';
            const getGameRef = (code) => doc(dbRef.current, `artifacts/${appId}/public/data/games`, code);
            
            useEffect(() => {
                const firebaseConfig = { apiKey: "AIzaSyCp8UFvV6eOVACbaLq7ylOjEZOBitUMkfc", authDomain: "dongapolice-24f1c.firebaseapp.com", projectId: "dongapolice-24f1c", storageBucket: "dongapolice-24f1c.appspot.com", messagingSenderId: "797826379293", appId: "1:797826379293:web:92a7231a8891be6527e0f4" };
                const app = initializeApp(firebaseConfig);
                dbRef.current = getFirestore(app);
                authRef.current = getAuth(app);
                signInAnonymously(authRef.current).then(() => {
                    onAuthStateChanged(authRef.current, user => { if (user) setUserId(user.uid); });
                });
                document.documentElement.classList.toggle('dark', isDarkMode);
            }, []);

            useEffect(() => { document.documentElement.classList.toggle('dark', isDarkMode); }, [isDarkMode]);

            const subscribeToGame = useCallback((code) => {
                if (gameUnsubscribe.current) gameUnsubscribe.current();
                const gameRef = getGameRef(code);
                gameUnsubscribe.current = onSnapshot(gameRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        setGameData(data);
                        setGameState(data.gameState);
                    } else {
                        alert("Game room closed.");
                        setGameState('home'); setGameData(null);
                    }
                });
            }, []);

            const createRoom = async () => {
                if (!username.trim()) { alert("Please enter your name!"); return; }
                const newRoomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                const gameRef = getGameRef(newRoomCode);
                await setDoc(gameRef, {
                    hostId: userId,
                    players: { [userId]: { name: username, score: 0, isSpeaking: false } },
                    chat: [], gameState: 'lobby', roomCode: newRoomCode,
                });
                subscribeToGame(newRoomCode);
            };

            const joinRoom = async (code) => {
                if (!username.trim()) { alert("Please enter your name!"); return; }
                const gameRef = getGameRef(code);
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) { alert("Room not found!"); return; }
                await updateDoc(gameRef, { [`players.${userId}`]: { name: username, score: 0, isSpeaking: false } });
                subscribeToGame(code);
            };
            
            const props = { gameData, userId, getGameRef, db: dbRef.current };

            const renderContent = () => {
                switch (gameState) {
                    case 'lobby': return <LobbyScreen {...props} />;
                    case 'reveal': return <RevealScreen {...props} />;
                    case 'police_guess': case 'raja_guess': return <GuessScreen {...props} />;
                    case 'result': return <ResultScreen {...props} />;
                    default: return <HomeScreen setUsername={setUsername} createRoom={createRoom} joinRoom={joinRoom} />;
                }
            };

            return (
                <div className="w-screen h-screen flex justify-center items-center">
                    <div className="absolute top-4 right-4 text-2xl cursor-pointer" onClick={() => setIsDarkMode(!isDarkMode)}>{isDarkMode ? '‚òÄÔ∏è' : 'üåô'}</div>
                    {renderContent()}
                    {gameData && gameState !== 'home' && <Chat {...props} username={username} />}
                </div>
            );
        }

        const HomeScreen = ({ setUsername, createRoom, joinRoom }) => {
            const [roomCodeInput, setRoomCodeInput] = useState('');
            const handleAction = async (action, arg) => { await Tone.start(); playSound('click'); action(arg); }
            return (
                 <div className="w-full max-w-md bg-[var(--surface-main)] p-8 rounded-2xl shadow-xl space-y-6">
                    <h1 className="text-4xl font-bold text-[var(--primary)]">Donga Police</h1>
                    <p className="text-xl font-semibold -mt-4">Royal Chits Edition</p>
                    <input onChange={e => setUsername(e.target.value)} type="text" className="input-field text-center" placeholder="Enter Your Name" />
                    <div className="space-y-3">
                        <button onClick={() => handleAction(createRoom)} className="btn bg-blue-600 text-white w-full">Create Room üëë</button>
                        <div className="flex items-center gap-3">
                            <input onChange={e => setRoomCodeInput(e.target.value.toUpperCase())} type="text" className="input-field uppercase" placeholder="Room Code" />
                            <button onClick={() => handleAction(joinRoom, roomCodeInput)} className="btn bg-gray-600 text-white">Join</button>
                        </div>
                    </div>
                     <p className="text-xs text-center text-gray-500 pt-4">A game by Krishnakanth</p>
                </div>
            );
        }
        
        const LobbyScreen = ({ gameData, userId, getGameRef }) => {
            const isHost = gameData.hostId === userId;
            const canStart = Object.keys(gameData.players).length >= 4;

            const startGame = async () => {
                playSound('click');
                const { players, roomCode } = gameData;
                const playerIds = Object.keys(players);
                let baseRoles = ['üëÆ Police', 'üïµÔ∏è‚Äç‚ôÇÔ∏è Donga', 'üëë Raja', 'üë∏ Rani', 'üß† Mantri', 'ü§ì Batulu'];
                let assignedRoles = ['üëÆ Police', 'üïµÔ∏è‚Äç‚ôÇÔ∏è Donga', 'üëë Raja', 'üë∏ Rani'];
                let extraRoles = ['üß† Mantri', 'ü§ì Batulu'];
                let i = 0;
                while (assignedRoles.length < playerIds.length) {
                    assignedRoles.push(extraRoles[i % extraRoles.length]);
                    i++;
                }
                const shuffledRoles = assignedRoles.sort(() => Math.random() - 0.5);
                const roles = {};
                playerIds.forEach((id, idx) => roles[id] = shuffledRoles[idx]);
                Object.keys(players).forEach(uid => { players[uid].revealed = false });
                await updateDoc(getGameRef(roomCode), { gameState: 'reveal', roles, players });
            };

            return (
                <div className="w-full max-w-md bg-[var(--surface-main)] p-8 rounded-2xl shadow-xl">
                    <h2 className="text-3xl font-bold mb-2">Lobby</h2>
                    <p>Room Code: <strong className="text-2xl text-[var(--primary)] tracking-widest">{gameData.roomCode}</strong></p>
                    <div className="space-y-2 my-6 min-h-[150px] bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                        {Object.values(gameData.players).map(p => <div key={p.name} className="bg-gray-200 dark:bg-gray-700 p-3 rounded-lg font-semibold flex justify-between items-center"><span>{p.name}</span> <span className={`text-2xl transition-opacity duration-300 ${p.isSpeaking ? 'opacity-100' : 'opacity-25'}`}>üéôÔ∏è</span></div>)}
                    </div>
                    {isHost && <button onClick={startGame} disabled={!canStart} className="btn bg-blue-600 text-white w-full text-xl">Start Game üî•</button>}
                    {!isHost && <p>Waiting for host to start...</p>}
                    {!canStart && <p className="text-sm text-gray-500 mt-2">Need at least 4 players to start.</p>}
                </div>
            );
        };
        
        const RevealScreen = ({ gameData, userId, getGameRef }) => {
            const myPlayer = gameData.players[userId];
            const myRole = gameData.roles[userId];
            const [emoji, name] = myRole.split(' ');

            const handleReveal = async () => {
                if(myPlayer.revealed) return;
                await Tone.start();
                playSound('flip');
                await updateDoc(getGameRef(gameData.roomCode), { [`players.${userId}.revealed`]: true });
            };
            
            useEffect(() => {
                const allRevealed = Object.values(gameData.players).every(p => p.revealed);
                if (allRevealed) {
                    setTimeout(() => {
                         updateDoc(getGameRef(gameData.roomCode), { gameState: 'police_guess' });
                    }, 1000);
                }
            }, [gameData.players]);

            return (
                <div className="flex flex-col items-center">
                    <h2 className="text-3xl font-bold mb-2">Your Secret Role Is...</h2>
                    <p className="mb-6">Don't show anyone! ü§´</p>
                    <div className="chit-scene" onClick={handleReveal}>
                        <div className={`chit ${myPlayer.revealed ? 'is-flipped' : ''}`}>
                            <div className="chit-face chit-front flex flex-col justify-center items-center"><div className="text-3xl">üé¥</div><div className="font-bold text-xl mt-2">Click to Reveal</div></div>
                            <div className="chit-face chit-back flex flex-col justify-center items-center"><div className="text-7xl">{emoji}</div><div className="text-3xl font-bold mt-2">{name}</div></div>
                        </div>
                    </div>
                    {myPlayer.revealed && <p className="text-lg mt-8 opacity-100 transition-opacity">Waiting for others...</p>}
                </div>
            );
        };
        
        const GuessScreen = ({ gameData, userId, getGameRef }) => {
            const { gameState, roles, players } = gameData;
            const policeId = Object.keys(roles).find(id => roles[id] === 'üëÆ Police');
            const rajaId = Object.keys(roles).find(id => roles[id] === 'üëë Raja');

            const isMyTurn = (gameState === 'police_guess' && userId === policeId) || (gameState === 'raja_guess' && userId === rajaId);
            const currentGuesser = gameState === 'police_guess' ? players[policeId] : players[rajaId];
            const prompt = gameState === 'police_guess' ? 'find the Donga üïµÔ∏è‚Äç‚ôÇÔ∏è' : 'find the Rani üë∏';

            const handleGuess = async (guessedId) => {
                playSound('click');
                const nextState = gameState === 'police_guess' ? 'raja_guess' : 'result';
                const guessField = gameState === 'police_guess' ? 'policeGuess' : 'rajaGuess';
                
                if (nextState === 'result') {
                    // This is the final guess, calculate results
                    const dongaId = Object.keys(roles).find(id => roles[id] === 'üïµÔ∏è‚Äç‚ôÇÔ∏è Donga');
                    const raniId = Object.keys(roles).find(id => roles[id] === 'üë∏ Rani');
                    
                    const policeGuessedCorrectly = gameData.policeGuess === dongaId;
                    const rajaGuessedCorrectly = guessedId === raniId;

                    const pointsMap = { 'üëë Raja': 1000, 'üë∏ Rani': 800, 'üëÆ Police': 500, 'üß† Mantri': 600, 'ü§ì Batulu': 300 };
                    const updatedPlayers = { ...players };

                    // Award points based on correct guesses
                    if (policeGuessedCorrectly) updatedPlayers[policeId].score += pointsMap['üëÆ Police'];
                    if (rajaGuessedCorrectly) updatedPlayers[rajaId].score += pointsMap['üëë Raja'];
                    
                    // Award points to others
                    Object.keys(roles).forEach(uid => {
                        if (['üë∏ Rani', 'üß† Mantri', 'ü§ì Batulu'].includes(roles[uid])) {
                            updatedPlayers[uid].score += pointsMap[roles[uid]] || 0;
                        }
                    });

                    let winType, dialogue;
                    if(policeGuessedCorrectly && rajaGuessedCorrectly) { winType = 'both_win'; dialogue = "Perfect teamwork! üëë‚ù§Ô∏èüö®"; playSound('win', 'G5'); }
                    else if(policeGuessedCorrectly || rajaGuessedCorrectly) { winType = 'one_win'; dialogue = "One mystery solved! üòâ"; playSound('win', 'C5'); }
                    else { winType = 'lose'; dialogue = "Total failure! üò¢ Both guesses wrong!"; playSound('lose'); }
                    
                    await updateDoc(getGameRef(gameData.roomCode), { gameState: 'result', players: updatedPlayers, result: { winType, dialogue, policeGuess: gameData.policeGuess, rajaGuess: guessedId } });

                } else {
                     await updateDoc(getGameRef(gameData.roomCode), { gameState: nextState, [guessField]: guessedId });
                }
            };
            
            return (
                <div className="text-center w-full max-w-lg">
                    <h2 className="text-3xl font-bold">{isMyTurn ? "Your turn!" : `Waiting for ${currentGuesser.name}...`}</h2>
                    <p className="text-xl my-4">They must {prompt}</p>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                        {isMyTurn && Object.entries(players).map(([uid, player]) => {
                            if (uid !== userId) return <button key={uid} onClick={() => handleGuess(uid)} className="btn bg-gray-600 text-white">{player.name}</button>;
                            return null;
                        })}
                    </div>
                </div>
            );
        };

        const ResultScreen = ({ gameData, userId, getGameRef }) => {
            const { hostId, roles, players, result } = gameData;
            const isHost = hostId === userId;
            
            const playAgain = async () => {
                playSound('click');
                const playerIds = Object.keys(players);
                let baseRoles = ['üëÆ Police', 'üïµÔ∏è‚Äç‚ôÇÔ∏è Donga', 'üëë Raja', 'üë∏ Rani', 'üß† Mantri', 'ü§ì Batulu'];
                let assignedRoles = ['üëÆ Police', 'üïµÔ∏è‚Äç‚ôÇÔ∏è Donga', 'üëë Raja', 'üë∏ Rani'];
                let extraRoles = ['üß† Mantri', 'ü§ì Batulu'];
                let i=0;
                while(assignedRoles.length < playerIds.length) { assignedRoles.push(extraRoles[i++ % extraRoles.length]); }
                const shuffledRoles = assignedRoles.sort(() => Math.random() - 0.5);
                const newRoles = {};
                playerIds.forEach((id, idx) => newRoles[id] = shuffledRoles[idx]);
                const resetPlayers = {...players};
                Object.keys(resetPlayers).forEach(uid => resetPlayers[uid].revealed = false);
                await updateDoc(getGameRef(gameData.roomCode), { gameState: 'reveal', roles: newRoles, players: resetPlayers, result: null, policeGuess: null, rajaGuess: null });
            };
            
            return (
                <div className="w-full max-w-2xl bg-[var(--surface-main)] p-8 rounded-2xl shadow-xl text-center relative overflow-hidden">
                    <Confetti type={result.winType} />
                    <h2 className="text-4xl font-bold mb-4">{result.dialogue}</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-4">
                        <div className="space-y-2 text-left bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 className="font-bold mb-2 text-lg">Final Roles</h3>
                            {Object.keys(roles).map(uid => <p key={uid}>{players[uid].name}: {roles[uid]}</p>)}
                        </div>
                        <div className="space-y-2 text-left bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 className="font-bold mb-2 text-lg">Scoreboard üèÜ</h3>
                            {Object.values(players).sort((a,b) => b.score - a.score).map(p => <p key={p.name}>{p.name}: {p.score} pts</p>)}
                        </div>
                    </div>
                    {isHost && <button onClick={playAgain} className="btn bg-blue-600 text-white w-full mt-4">Play Next Round üîÅ</button>}
                    {!isHost && <p>Waiting for host to start a new game...</p>}
                </div>
            );
        };

        const Chat = ({ gameData, username, getGameRef, userId, db }) => {
            const [chatInput, setChatInput] = useState('');
            const [isOpen, setIsOpen] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);
            const messagesEndRef = useRef(null);
            const localStreamRef = useRef();
            const peerConnections = useRef(new Map());
            const audioContainerRef = useRef(null);
            
            // Effect to setup audio container
             useEffect(() => {
                audioContainerRef.current = document.getElementById('audio-container');
            }, []);

            const handlePtt = async (speaking) => {
                playSound(speaking ? 'ptt_on' : 'ptt_off');
                setIsSpeaking(speaking);
                if (localStreamRef.current) {
                    localStreamRef.current.getAudioTracks().forEach(track => track.enabled = speaking);
                }
                await updateDoc(getGameRef(gameData.roomCode), { [`players.${userId}.isSpeaking`]: speaking });
            };
            
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [gameData.chat]);

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!chatInput.trim()) return;
                playSound('message');
                await updateDoc(getGameRef(gameData.roomCode), { chat: arrayUnion({ name: username, text: chatInput }) });
                setChatInput('');
            };

            return (
                 <div className="fixed bottom-4 right-4 z-50">
                    <div className="flex flex-col items-end gap-3">
                        <div id="chat-window" className="w-80 h-96 bg-[var(--surface-main)] rounded-xl shadow-2xl flex-col" style={{ display: isOpen ? 'flex' : 'none' }}>
                            <div id="chat-messages" className="flex-grow p-3 overflow-y-auto text-left">
                                {gameData.chat?.map((msg, i) => <div key={i} className="mb-2"><strong>{msg.name}:</strong> {msg.text}</div>)}
                                <div ref={messagesEndRef} />
                            </div>
                            <form onSubmit={handleSubmit} className="flex p-2 border-t border-gray-300 dark:border-gray-600">
                                <input value={chatInput} onChange={e => setChatInput(e.target.value)} className="input-field !rounded-r-none" placeholder="Say something..." autoComplete="off" />
                                <button type="submit" className="btn bg-blue-600 text-white !rounded-l-none">Send</button>
                            </form>
                        </div>
                        <div className="flex items-center gap-3">
                           <button 
                             className={`w-16 h-16 rounded-full text-3xl flex items-center justify-center text-white transition-colors ${isSpeaking ? 'bg-red-500' : 'bg-green-500'}`}
                             onMouseDown={() => handlePtt(true)} onMouseUp={() => handlePtt(false)}
                             onTouchStart={() => handlePtt(true)} onTouchEnd={() => handlePtt(false)}
                           >üéôÔ∏è</button>
                           <div id="chat-toggle" className="w-16 h-16 rounded-full text-3xl flex items-center justify-center bg-blue-600 text-white cursor-pointer" onClick={() => setIsOpen(!isOpen)}>{isOpen ? 'üîΩ' : 'üó®Ô∏è'}</div>
                        </div>
                    </div>
                </div>
            )
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
